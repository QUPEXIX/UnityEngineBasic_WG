namespace FirstProject
{
    // 철수 객체를 heap 영역에 할당할 때 필요한 메모리: 8byte(멤버 변수 크기 총합)
    class 철수
    {
        uint 나이;
        int 돈;
    }

    // 영희 객체를 heap 영역에 할당할 때 필요한 메모리: 8byte(키+나이)
    class 영희
    {
        float 키;
        // 전역변수: 어디서나 접근 가능한 변수
        // 클래스의 멤버변수도 전역변수임.
        public int 나이=1; // 변수 선언 부분에 어떤 값을 대입하겠다는 대입연산을 쓰면 해당 값을 초기 데이터로 쓰겠다는 명시(Data 영역에 할당), 즉 초기화를 의미

        // 정적 변수: 동적으로 할당할 수 없는 변수. 런타임 중 메모리에 추가적인 할당이 불가능하며, 객체 할당 시 메모리가 필요하지 않음. static으로 생성.
        static char 성별 = '여';

        // 접근제한자(Access Modifier): 외부에서의 멤버변수 접근 가능 여부를 제한하는 키워드
        // 클래스는 캡슐화를 컨셉으로 한 사용자 정의 자료형임.
        // 접근제한자를 명시하지 않으면 외부 접근을 차단(private)하는 게 기본값
        // private: 다른 클래스는 접근 불가
        // protected: 자식 클래스까지만 접근 가능
        // internal: Assembly(exe, dll 등 코드조각) 단위로만 접근 가능
        // public: 모두 접근 가능

        // 클래스 생성자
        // Heap 메모리 영역에 클래스 타입의 객체를 할당
        // 멤버변수의 초기화를 진행
        // 생성된 객체의 주소 참조를 반환
        public 영희()
        {
        }

        // 클래스 소멸자
        // 해당 객체가 할당된 메모리 영역을 시스템에 반환하는 함수
        // CLR의 가비지 컬렉터 기능이 알아서 소멸시키기 때문에 C#에서는 직접 호출할 일은 없음.
        ~영희()
        {
        }

        // void: 타입이 정해지지 않음(반환타입이 없음)
        void SayMyAge()
        {
            //todo -> 이름 출력하기
        }

        // 지역변수: {} 내에서 정의되어 해당 연산 중에만 메모리에 할당되는 변수
        // 매개변수(파라미터)도 지역변수의 일종

        // 인스턴스 멤버(static이 안 붙은 것) 함수는 데이터를 참조할 목표 객체에 대한 참조 파라미터가 생략되어 있음. 따라서 클래스의 기본값이 아닌 영희1과 같은 객체에 변화가 생김
        // this 키워드로 해당 목표객체 참조 가능
        // this 키워드도 생략 가능
        // 원래 형식: public bool 나이먹기(영희 목표객체, int 먹을나이) <- 목표객체에 해당하는 것이 영희1, 영희2 등
        public bool 나이먹기(int 먹을나이)
        {
            int 예상나이 = 나이 + 먹을나이;
            // if 구문: if (논리형 실행조건) {}
            // 만약 예상나이가 음수면 나이를 못 먹는다고 할 것.
            if (예상나이 < 0)
            {
                return false;
            }
            else
            {
                나이 = 예상나이;
                return true;
            }
        }
    }

    internal class Program
    {
        // 변수: 아직 정해지지 않은 값
        // 객체: 어떤 사물이나 사념을 만들기 위해 확보한 특정 메모리 공간
        // 초기화: 확보한 메모리 공간에 값을 처음 써 넣는 과정
        // 인스턴스: 초기화가 된 객체(C#에서는 인스턴스가 아닌 객체는 없음)
        // 클래스: 어떤 객체를 만드려면 어떤 종류의, 얼마만큼의 메모리를 할당해야 하는지와, 어떤 기능이 있는지에 대한 정의
        // 사용자 정의 자료형: 개발자가 직접 얼마만큼의 메모리를 어떻게 할당해야 하는지 정의할 수 있는 자료형
        // 멤버변수: 사용자 정의 자료형에서 특정 공간을 구성하는 구성원으로 정의된 변수
        // 클래스는 멤버들을 가짐. 어떤 변수가 필요하다고 정의하면 해당 변수를 멤버로 가짐.
        // 객체를 만들 때 함수를 위한 공간은 따로 할당하지 않음.
        // 함수 호출: 코드 영역의 함수 원본을 찾아서 그 복제본을 Stack 영역에 할당하고 매개변수 영역에는 인자로 전달할 값을 대입함.
        // 매개변수(파라미터): 인자를 함수에 전달하는 매개체로 사용되는 변수
        // 연산이 끝나는 함수는 해당 메모리에 대한 제어권을 시스템에 반환해야 함.(ex. return;)

        int a;
        uint b;
        short c;
        ushort d;
        long e;
        ulong f;
        char g;
        float h;
        double i;
        bool j;

        //메인 함수, 프로그램 실행시 처음 호출되는(실행되는) 함수
        static void Main(string[] args)
        {
            // 문자열형 string은 클래스 타입이기 때문에, heap 영역에 객체를 만들고 해당 참조를 사용함.
            // heap 영역에 할당하는 객체의 크기는 문자개수x2byte+1byte(null byte)
            // null byte가 붙은 이유는 문자열의 끝을 명시하기 위함.
            string string1 = "Something blabla"; // 문자열 상수 표기는 ""로 함.

            // .: 멤버접근연산자
            Console.WriteLine("Hello, World!");

            // 값 타입(ex. int a = 1;) vs 참조 타입(ex. 영희 영희1 = new 영희();)
            // 값 타입: 데이터를 직접 메모리에 쓰고 읽는 타입
            // 참조 타입: 특정 메모리 주소를 통해 간접적으로 해당 메모리에 데이터를 쓰고 읽는 타입
            // 포인터 타입: 메모리 주소를 쓰고 읽는 타입(C#에서는 unsafe 코드 작성 외에 사용하지 않음)
 
            // new: 동적할당키워드(메모리를 동적으로 할당하겠다고 명시하는 키워드)
            // 객체 주소 참조 변수
            // 영희1은 편의상 클래스 타입 객체라고 부르지만 실제로는 영희라는 객체를 참조하기 위한 변수
            영희 영희1 = new 영희(); // 영희 객체를 만들고 영희가 있는 메모리 주소를 영희1이라는 변수에 저장
            영희 영희2 = new 영희();
            Console.WriteLine(영희1.나이먹기(1));

            string somethingToPrint = "영희의 나이는 " + 영희1.나이 + "살입니다."; // 영희1.나이.ToString()에서 ToString()이 생략됨.
            Console.WriteLine(somethingToPrint);
            Console.WriteLine($"영희의 나이는 {영희1.나이}살입니다.");

            int int1 = 1;
            long long1 = int1; // 암시적 캐스팅;int의 최대 데이터 양이 long보다 작기 때문에 명시적 캐스팅 없이 형 변환이 가능함.
            // 변수의 Promotion(승격): 크기가 더 큰 자료형 레지스터로 작은 데이터를 읽었을 때 읽는 과정에서 해당 데이터의 자료형이 바뀌는 효과

            long long2 = 2;
            int int2 = (int)long2; // 명시적 캐스팅;long2의 데이터 양이 int로 표현이 가능한 양이기 때문에 형 변환이 가능함.
        }
    }
}